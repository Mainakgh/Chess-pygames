-->This program is a chess game. The user may play against a friend or the
computer.

-->The game state is mainly stored as a 2D list of strings, and most of the
processing is thus done on a list of strings.

--> The GUI takes the current state and displays it on the screen. The GUI allows
 drag and drop movement of pieces as well as click-click movement.
 
-->The Data Structure used here is a Search tree(in AI Mode). 
   Other Data Structures Used:
   2D List: For storing state of game.
   List: For Storing all possible moves in AI mode.
   Dictionary: For storing results from Alpha-beta pruning & Transposition Table.

-->The AI that plays against the human evaluates all possible moves made by either
 player up to a certain level of depth. The AI evaluates each position by giving
 it a score. The higher the value of the score, the more favourable a position
 is for white and the lower the value of the score, the more favourable the
 position is for black. Knowing that white will try to get the score to be higher
 and black will try and get the score to be lower, the AI assumes best play from
 either side as it traverses up the search tree and chooses the best move to be
 played. A problem that may arise is the number of postions that need to be
 evaulated. Even at 3 levels of depth, thousands of positions have to be
 evaluatd.


                              xx--------------------xx
------Several methods are used in this program to reduce positions that are searched:----
 1. Alpha-beta pruning:
 Alpha-beta pruning is a modified version of the minimax algorithm. It is an optimization technique for the minimax algorithm.Alpha-beta pruning can be applied at any depth of a tree, and sometimes it not only prune the tree leaves but also entire sub-tree.
The two-parameter can be defined as:
       a. Alpha: The best (highest-value) choice we have found so far at any point along the path of Maximizer. The initial value of alpha is -∞.
       b. Beta: The best (lowest-value) choice we have found so far at any point along the path of Minimizer. The initial value of beta is +∞
    Implementation in Game:
  As a result of  evaluating a position it can be found
 that a portion of the search tree can be ignored as no further evaluations can
 guarantee better results. This can happen because white and black area against
 one another. White plays what is best for it and black plays what is best for it,
 so it would make sense for white to ignore any portion of the tree where black
 has a clear upperhand that it can choose to play.


 2. Transposition table:
 A transposition table is a cache of previously seen positions, and associated evaluations, in a game tree generated by a computer game playing program. If a position recurs via a different sequence of moves, the value of the position is retrieved from the table, avoiding re-searching the game tree below that position. 
 
  Often, two different pathways in a search tree can result
 in the same board being evaluated. Instead of evaluating the same board several
 times, the program stores a table of values in a dictionary where the keys are
 the positions. This way, repeated positions can have their evaluations looked up
 fairly quickly, as the board state is hashed.
 
 
 
 3. Opening Book - 
 Chess programs often look up the positions at the beginning of the game in an Opening Book. The opening database can then be used as long as the opponent plays a new move from the database, so usually more common opening lines will be stored to a much higher depth than the uncommon ones. As soon as the program is "out of book" it has to continue using the normal search routines.


 The opening book is again a dictionary that stores board
 positions often seen in the beginning few moves in chess. Appropraite moves that
 can be played at such positions is stored in the dictionary. A random move is
 selected and played from the list of suggested moves wihtout searching if the AI
 finds itself confronting a such a board postion. Note that this opening book was
 recorded by myself and so it does not have many positions stored in it.
      
                           xx-----------------------------xx
      
 In order to traverse the search tree as above, the AI needs to know how to evaluate the
 board at any position to decide if white or black has the advantage. Our evaluation
 function currently looks at three main things when evaluating the board:
    a) Material for white and black- Each piece has a value and the more pieces you have,
        the better off your position is likely to be. For example, if white has an extra
        queen, it has an advantage over black.
    b) Piece-square table values - for each piece, there is a table that stores the best
        squares that the particular piece should occupy. So if white has a knight at a
        good square that controls the centre of the board, whereas black has a knight
        at the corner of the board, the situation is evaluated as being more favourable
        for white.
    c) Reduction in points for doubled pawns, isolated pawns, and blocked pawns. If any
        side has a set of pawns with the above features their points are slightly lower
        to indicate a slight disadvantage in such a position.
    d) A checkmate: a position where this has occured gets a very high point, so that the
        AI moves towards this if it can. (or avoids it).
                        xx-----------------------------------------xx
                        
                        

-------------There are three classes used in this program:-----------------------
 1. GamePosition - This class stores a chess position. A chess position constitutes several
 features that specify the state of the game, such as the the player that has to play next,
 castling rights of the players, number of irreversible moves played so far, the positions of
 pieces on the board, etc.
 
 2. Shades - This is used for GUI. A shade is a transparent colored image that is displayed on
 a specific square of the chess board, in order to show various things to the user such as
 the squares to which a piece may move, the square that is currently selected, etc. The class
 stores a reference to the image that the instance of the class should display when needed. It
 also stores the coordinates at which the shade would be applied.
 
 3. Piece - This is also used for GUI. A Piece object stores the information about the image
 that a piece should display (pawn, queen, etc.) and the coordinate at which it should be
 displayed on thee chess board.
                                xx----------------xx 
 
---------The functions in this file may be classified into three main groups:-----------
  1. Chess Processing Functions - these are the functions that work with variables
  that hold the information about game state.
  
  2. GUI Functions - These are the functions that work together to display the
  chess board to the user and get the user's input as well, so that they may be
  passed on to the Chess Processing Functions.
  
  3. AI related functions - These are the functions involved in helping the
  computer make decisions in terms of what should be played.
  
  
  
  ------------Functions working with AI Algorithm-----------------------
  1.negamax(position,depth,alpha,beta,colorsign,bestMoveReturn,root=True)-
   This function takes as its inputs a position, and a depth to which moves should be 
 analysed. It will generate moves and analyse resulting positions to decide the
 best move to be played for the AI. Alpha and beta are lower and upper bounds to
 a position's possible score values and allows for alpha-beta pruning. Colorsign indicates the player to move.
  
 2.bestMoveReturn -
  is a list that will be assigned the move to be played.
 Returning is not possible in this case because threading is used. root is a 
 variable that keeps track of whether the original node is processing now or a 
 lower node. 
 
 
 3.evaluate(position) - 
 This function takes as input a position to be analysed.
 It will look at the positioning of pieces on the board to judge whether white
 has an advantage or black. If it returns zero, it means it considers the 
 position to be equal for both sides. A positive value is an advantage to the
 white side and a negative value is an advantage to the black side.

 4.pieceSquareTable(flatboard,gamephase)- 
 Gives a position a score based solely
 on tables that define points for each position for each piece type.

 5.doubledPawns(board,color) - This function counts the number of doubled pawns
 for a player and returns it. Doubled pawns are those that are on the same file.

 6.blockedPawns(board,color) - This function counts the number of blocked pawns
 for a player and returns it. Blocked pawns are those that have a piece in front
 of them and so cannot advance forward.

 7.isolatedPawns(board,color) - This function counts the number of isolated pawns
 for a player. These are pawns that do not have supporting pawns on adjacent files
 and so are difficult to protect.
                             xxx------------------------xxx
                             
                             
                             
    ---------------------GUI Function-----------------------
 1.chess_coord_to_pixels(chess_coord) - This function takes as input a chess coordinate such as (4,7). It returns the top left corner pixel at which a piece of the given size should be
 placed on the board for it to appear at the correct square.

 2.pixel_coord_to_chess(pixel_coord) - Does the exact opposite of above, namely taking the 
 pixel coordinate and giving back the chess coordinate of a particular square.

 3.getPiece(chess_coord) - Gives back the reference to the Piece object that occupies
 a particular chess coordinate.

 4.createPieces(board) - Loops through all the pieces in the inputted board array
 and creates an instance of Piece class for each of them. Returns a list of two
 lists: one that contains all the references to the white pieces, and the other 
 for black.

 3.createShades(listofTuples) - This will modify the global list listofShades. It
  will create instance of class Shade for all the specified coordinates given in
  listofTuples (the input argument). These squares are ones that are attacked by
  a particular piece. Furthermore, it will append other appropriate shades as well,
  such as shades used to show checkmate or stalemate.

 4. drawBoard() - Blits to the screen the board, the pieces, and the shades needed
 to make the game look nice.
                                  xx--------------------------------xx
                  
                  
 ---------------------Functions For Chess Processing---------                                 
  1.drawText(board) - This function is not called in this program. It is useful for debugging
 purposes, as it allows a board to be printed to the screen in a readable format.

 2.isOccupied(board,x,y) - Returns true if a given coordinate on the board is not empty, and
 false otherwise.

 3.isOccupiedby(board,x,y,color) - Same as above, but only returns true if the square
 specified by the coordinates is of the specifc color inputted.

 4.filterbyColor(board,listofTuples,color) - This function takes the board state, a list
 of coordinates, and a color as input. It will return the same list, but without
 coordinates that are out of bounds of the board and also without those occupied by the
 pieces of the particular color passed to this function as an argument. In other words,
 if 'white' is passed in, it will not return any white occupied square.

5.lookfor(board,piece) - This functions takes the 2D array that represents a board and finds 
 the indices of all the locations that is occupied by the specified piece. The list of 
 indices is returned.

 6.isAttackedby(position,target_x,target_y,color) - This function checks if the square specified
 7.by (target_x,target_y) coordinates is being attacked by any of a specific colored set of pieces.

 8.findPossibleSquares(position,x,y,AttackSearch=False) - This function takes as its input the
 current state of the chessboard, and a particular x and y coordinate. It will return for the
 piece on that board a list of possible coordinates it could move to, including captures and 
 excluding illegal moves (eg moves that leave a king under check). AtttackSearch is an
 argument used to ensure infinite recursions do not occur.

 9.makemove(position,x,y,x2,y2) - This function makes a move on the board. The position object
 gets updated here with new information. (x,y) are coordinates of the piece to be moved, and
 (x2,y2) are coordinates of the destination. (x2,y2) being correct destination (ie the move
 a valid one) is not checked for and is assumed to be the case.

 10.opp(color) - Returns the complimentary color to the one passed. So inputting 'black' returns

 11.isCheck(position,color) - This function takes a position as its input and checks if the
 King of the specified color is under attack by the enemy. Returns true if that is the case, 
 and false otherwise.

 12.isCheckmate(position,color=-1) - This function tells you if a position is a checkmate.
Color is an optional argument that may be passed to specifically check for mate against a
 specific color.

 13.isStalemate(position) - This function checks if a particular position is a stalemate.
 If it is, it returns true, otherwise it returns false.

 14.getallpieces(position,color) - This function returns a list of positions of all the pieces on the board of a particular color.

 15.allMoves(position, color) - This function takes as its argument a position and a color/colorsign that represents a side. It generates a list of all possible moves for that side and returns it.

 16.pos2key(position) - This function takes a position as input argument. For this particular 
 position, it will generate a unique key that can be used in a dictionary by making it hashable.
